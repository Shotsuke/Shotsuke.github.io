---
title: Dinitz' Algorithm The Original Version and Even's Version
date: 2024-04-17 20:00:00
categories: "Paper Notes"
tags: 
    - Graph Theorem and Algorithms
    - Read Paper
    - Note
---

# [Dinitz' Algorithm: The Original Version and Even's Version](https://doi.org/10.1007/11685654_10)

## 1. What is and Why use Dinitz' Algorithm

åœ¨æˆ‘ä»¬ä½¿ç”¨æœ´ç´ çš„ä¸æ–­å¯»æ‰¾å¢å¹¿è·¯çš„ç®—æ³•ï¼ˆè§ å›¾è®ºä¸ç®—æ³• < Graph Theory and Algorithms > Ford-Fulkerson Algorithmï¼‰ï¼Œå¯èƒ½ä¼šå¯¹æŸäº›è¾¹è®¡ç®—åå‘æ—¶é‡å¤å¤šæ¬¡ã€‚æ•…å¼•å…¥Dinitzç®—æ³•æ¥åŠ é€Ÿã€‚

## 2. The Origin Dinitz' Algorithm

### Main Body and Example

![Main Body of Dinitz'z Algorithm](\../imgs/Graph-Theory-and-Algorithms/Main%20Body%20of%20Dinitz'z%20Algorithm.png)

- (a) åˆå§‹å›¾$G$ï¼ˆè¾¹å®¹é‡æœªç”»å‡ºï¼‰
- (b) ä»æºç‚¹$s$å¼€å§‹çš„ä¸€æ£µBFSæ ‘ï¼Œå…¶ä¸­æœ‰ä¸€æ¡ä»$s$åˆ°$t$çš„è·¯å¾„å·²ç»è¢«ç²—ä½“æ ‡æ³¨ã€‚çº¦å®šè¢«é¥±å’Œçš„è¾¹ä»¥æ‰“å‰è¡¨ç¤ºã€‚
- (c) å°†(b)ä¸­çš„BFSæ ‘è¿›è¡Œæ‰©å……ã€‚ä¸åˆå§‹å›¾ç›¸æ¯”ï¼Œæˆ‘ä»¬ä»…ä»…éœ€è¦ä¸æºç‚¹$s$è·ç¦»ï¼ˆä¹‹åä¹Ÿç§°ä¸ºæ·±åº¦ï¼‰ä¸åŒé¡¶ç‚¹ä¹‹é—´çš„å¼§ï¼Œè€Œä¸å…³å¿ƒæ‰€æœ‰æ·±åº¦ç›¸åŒç‚¹ä¹‹é—´çš„å¼§ã€‚è®°$V\_0 = \\{ s \\}$ï¼Œ$V\_i$è¡¨ç¤ºæ‰€æœ‰ä¸æºç‚¹è·ç¦»$i$çš„ç‚¹ï¼Œ$E\_i$è¡¨ç¤ºæ‰€æœ‰ä»$V\_\{i-1\}$åˆ°$V_i$çš„å¼§ã€‚å®šä¹‰$L(s) = (\cup\{V\_i\} , \cup\{E\_i\})$ã€‚
- (d) æˆ‘ä»¬å¹¶ä¸å…³å¿ƒä¸$t$åŒå±‚æ¬¡çš„ç‚¹ä»¥åŠå±‚æ¬¡æ›´æ·±çš„å…¶ä»–ç‚¹ï¼Œé‚£ä¼šåœ¨ä¹‹åçš„é˜¶æ®µä¸­å…³å¿ƒï¼Œå› æ­¤å¯ä»¥å°†$L(s)$ç²¾ç®€ä¸º$\hat{L}(s,t)$ã€‚$\hat{L}(s,t)$ä»…ä»…åŒ…å«$l$å±‚ï¼Œå…¶ä¸­$l$ä¸ºä»$s$åˆ°$t$çš„è·ç¦»ï¼Œç§°ä¸º$\hat{L}(s,t)$çš„é•¿åº¦ï¼ŒåŒæ—¶è®°$\hat{L} = \hat{L}(s,t)$ï¼Œå¹¶ç§°ä¸ºåˆ†å±‚å­å›¾ã€‚è¿™ä¸ªç²¾ç®€æ˜¯ç®€å•çš„ï¼Œåªéœ€è¦ä»$t$åå‘åšä¸€æ¬¡BFSå³å¯ã€‚åœ¨è¿™ä¹‹åè¿è¡Œ$PathFinding$å¾—åˆ°ä¸€æ¡ä»æºç‚¹åˆ°æ±‡ç‚¹çš„è·¯å¾„ã€‚
  - $PathFinding$ï¼šä»æ±‡ç‚¹$t$å¼€å§‹ï¼Œä¸æ–­åœ°å¯»æ‰¾å…¥è¾¹ï¼Œç›´åˆ°å›åˆ°æºç‚¹$s$ï¼Œè¿”å›è¿™æ¡è·¯å¾„ã€‚
  - åœ¨è¿™ä¸ªä¾‹å­ä¸­æˆ‘ä»¬å‡å®šæœ‰ä¸¤æ¡è¾¹è¢«é¥±å’Œäº†ã€‚å¯¹äºåˆ†å±‚å­å›¾æœ‰ï¼š
    - $V\_i = \\{t\\}$
    - æ‰€æœ‰$\hat{V}\_i$ä¸­çš„ç‚¹å‡æ»¡è¶³ï¼šç¦»æºç‚¹è·ç¦»$i$ï¼Œç¦»æ±‡ç‚¹è·ç¦»$l-i$
    - åˆ†å±‚å­å›¾$\hat{L}$æ˜¯æ‰€æœ‰èƒ½å¤Ÿå½¢æˆä»æºç‚¹åˆ°æ±‡ç‚¹æœ€çŸ­è·¯çš„ç‚¹å’Œå¼§çš„é›†åˆ
    - ä¸å­˜åœ¨â€œæ­»èƒ¡åŒâ€ï¼šé™¤æºç‚¹å¤–ï¼Œæ²¡æœ‰ç‚¹æ²¡æœ‰å…¥è¾¹ï¼›é™¤æ±‡ç‚¹å¤–ï¼Œæ²¡æœ‰ç‚¹æ²¡æœ‰å‡ºè¾¹
- (e) ç§»é™¤é¥±å’Œå¼§
- (f) åœ¨ç§»é™¤ï¼ˆå¯èƒ½ä¸æ­¢ä¸€æ¡ï¼‰å¼§åï¼Œéœ€è¦æ‰§è¡Œæ¸…ç†$Cleaning$æ“ä½œï¼Œå°†ä¸åœ¨éœ€è¦çš„ç‚¹ä¸è¾¹ä»åˆ†å±‚å­å›¾ä¸­ç§»é™¤ã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œ$RightPass$æ£€æµ‹åˆ°æ­»ç‚¹$a$ï¼Œå°†å…¶å’Œå…¶æ‰€è¿å¼§ç§»é™¤ã€‚
  - $Cleaning$ï¼šç»´æŠ¤æ‰€æœ‰å·²é¥±å’Œè¾¹$Sat$ï¼Œåˆå§‹åŒ–$Q^l = Q^r = Sat$ã€‚ç„¶åä¸æ–­åœ°æ‰§è¡Œ$RightPass$å’Œ$LeftPass$ç›´è‡³ä¸¤ä¸ªé˜Ÿåˆ—å‡ä¸ºç©ºï¼Œé¡ºåºæ— å…³ã€‚æˆ‘ä»¬ä¸å¦¨çº¦å®šå°†æºç‚¹æ‘†åœ¨æˆ‘ä»¬çš„æœ€å·¦æ‰‹è¾¹ï¼Œè€Œæ±‡ç‚¹æ‘†åœ¨æœ€å³æ‰‹è¾¹ï¼Œå…¶ä½™ç‚¹æŒ‰ç…§æ·±åº¦çš„å¢åŠ ä»å·¦å‘å³æ’åˆ—ã€‚
  - $RightPass$ï¼šå¯¹äºä»»æ„è¾¹ï¼ˆå…¶å®å°±æ˜¯å¼§ï¼‰$e \in Q^r$ï¼Œå¦‚æœå®ƒçš„å³æ‰‹ç‚¹æ²¡æœ‰å…¥è¾¹ï¼Œé‚£ä¹ˆå°†å…¶å’Œå®ƒçš„æ‰€æœ‰å‡ºè¾¹åˆ é™¤ï¼Œå¹¶å°†è¿™äº›è¾¹å…¥é˜Ÿ$Q^r$
  - $LeftPass$ï¼šå¯¹äºä»»æ„è¾¹ï¼ˆå…¶å®å°±æ˜¯å¼§ï¼‰$e \in Q^l$ï¼Œå¦‚æœå®ƒçš„å·¦æ‰‹ç‚¹æ²¡æœ‰å‡ºè¾¹ï¼Œé‚£ä¹ˆå°†å…¶å’Œå®ƒçš„æ‰€æœ‰å…¥è¾¹åˆ é™¤ï¼Œå¹¶å°†è¿™äº›è¾¹å…¥é˜Ÿ$Q^l$
- (g) å¯è§(f)ä¸­çš„åˆ†å±‚å­å›¾å·²ç»ä¸è¿é€šäº†ï¼Œä½“ç°åœ¨è¿›è¡ŒDFSæ—¶æŠ¥å‘Šæµé‡ä¸º0ï¼Œå› æ­¤éœ€è¦é‡æ–°ç”Ÿæˆåˆ†å±‚å­å›¾ã€‚ç±»ä¼¼çš„ç»§ç»­æ‰§è¡ŒDFSè¿›è¡Œè·¯å¾„æœç´¢ï¼Œåœ¨ä¾‹å­ä¸­æˆ‘ä»¬æ‰¾åˆ°äº†ä¸€æ¡é•¿åº¦ä¸º4çš„è·¯å¾„ï¼Œå¹¶ä¸”é¥±å’Œäº†ä¸€æ¡å¼§ã€‚è™šçº¿æ¡†ä¸­çš„ä¸¤ä¸ªç‚¹ä½äºç›¸åŒæ·±åº¦ã€‚ä¾ç…§æƒ¯ä¾‹æ‰§è¡Œ$Cleaning$ï¼Œæˆ‘ä»¬å°†ç‚¹$a$ä»¥åŠå…¶æ‰€æœ‰å‡ºè¾¹åˆ é™¤ï¼Œç„¶åå°†è¿™æ¡è·¯å¯¹åº”çš„è¡¥å¼ºæµé‡åŠ åˆ°ç­”æ¡ˆæµé‡ä¸­ã€‚
- (h) åœ¨å½“å‰çš„åˆ†å±‚å­å›¾ä¸­ï¼ŒDFSæŠ¥å‘Šæµé‡ä¸ä¸º0ï¼Œå› æ­¤é‡å¤ç±»ä¼¼æ“ä½œã€‚
- (i) åœ¨æœ€å¼€å§‹çš„æ—¶å€™ï¼ŒDinitzå‡å®šå¦‚æœä¸¤ç‚¹ä¹‹é—´æ²¡æœ‰å¼§ï¼Œé‚£ä¹ˆæ·»åŠ ä¸€æ¡æ‹¥æœ‰0å®¹é‡çš„å¼§æ¥è¡¥å…¨ï¼Œè¿™æ˜¾ç„¶æ˜¯ä¸å½±å“æœ€ç»ˆè¾“å‡ºçš„ã€‚åœ¨å‰©ä½™ç½‘ç»œ$G\_f$ä¸­ï¼Œä»æºç‚¹æ‰§è¡Œçš„BFSæ— æ³•åˆ°è¾¾æ±‡ç‚¹ï¼Œå› æ­¤ç®—æ³•ç»“æŸã€‚

### Pseudocode

```pseudocode
The Original Dinitz Algorithm
Input:
    a flow network G =(V,E,c,s,t),
    a feasible flow f, in G (equal to zero, by default).
/* Phase Loop:*/
    dowhile
    begin
        Build Ë†L(s,t) in Gf, using the extended BFS;
        if Ë†L(s, t) = âˆ… then return f
        else Ë†L â† Ë†L(s,t);
        /* Iteration Loop:*/
        while Ë†L is not empty do
        /*Iteration Invariant: Ë†L is the union of all shortest augmenting paths*/
        begin
            P â† PathFinding(Ë†L);
            Sat â† FlowChange(P);
            /* Cleaning(Ë†L): */
            begin
                Removal of edges in Sat;
                Qr,Ql â† Sat;
                RightPass(Qr);
                LeftPass(Ql);
            end;
        end;
    end;
```

### Summary

- DA ç”±å¤šä¸ªé˜¶æ®µç»„æˆã€‚æ¯ä¸ªé˜¶æ®µéƒ½åŒ…å«ä½¿ç”¨å›ºå®šé•¿åº¦çš„æœ€çŸ­å¢å¹¿è·¯å¾„æ¥æ”¹å˜æµç¨‹çš„è¿­ä»£
- åœ¨æ¯ä¸ªé˜¶æ®µå¼€å§‹æ—¶ï¼Œæ‰©å±•çš„ BFS åœ¨$O(|E|)$æ—¶é—´å†…æ„å»ºä¸€ä¸ªåˆ†å±‚ç½‘ç»œæ•°æ®ç»“æ„ï¼Œé•¿åº¦ä¸º$ğ¿$ã€‚åˆ†å±‚ç½‘ç»œåœ¨è¯¥é˜¶æ®µæŒç»­ä¿æŒä¸ºæ‰€æœ‰é•¿åº¦ä¸ºçš„æœ€çŸ­å¢å¹¿è·¯å¾„çš„å¹¶é›†ï¼Œç›´åˆ°å®ƒæ¶ˆå¤±ï¼Œæ€»æ—¶é—´$O(|E|)$ã€‚
- $\hat{L}$çš„åˆ†å±‚ç»“æ„åŠå…¶ä¸­ä¸å­˜åœ¨æ­»èƒ¡åŒå…è®¸åœ¨$O(l)=O(|V|)$æ—¶é—´å†…æ‰§è¡Œ$FF$çš„æ¯æ¬¡è¿­ä»£ã€‚
- åœ¨$FF$çš„æ¯æ¬¡è¿­ä»£åï¼Œåˆ†å±‚ç½‘ç»œéƒ½ä¼šè¢«ä¸¥æ ¼ä¿®å‰ªï¼Œè€ƒè™‘é›†åˆ$Sat$çš„å¤§å°ã€‚å› æ­¤ï¼Œæ¯ä¸ªé˜¶æ®µçš„è¿­ä»£æ¬¡æ•°å—$|E|$é™åˆ¶ã€‚
- å½“åˆ†å±‚ç½‘ç»œæ¶ˆå¤±æ—¶ï¼Œä¸å­˜åœ¨é•¿åº¦å°äºæˆ–ç­‰äºå½“å‰æµçš„å¢å¼ºè·¯å¾„ã€‚å› æ­¤ï¼Œä¸‹ä¸€å±‚ç½‘ç»œçš„é•¿åº¦ç­‰äºå½“å‰æœ€çŸ­å¢å¹¿è·¯å¾„çš„é•¿åº¦ï¼Œä¸¥æ ¼å¤§äº$l$ã€‚
- ç”±äº$\hat{L}$çš„é•¿åº¦é€é˜¶æ®µå¢é•¿ï¼Œå› æ­¤æœ€å¤šæœ‰$|V| âˆ’ 1$ä¸ªé˜¶æ®µã€‚
- å› æ­¤æ€»æ—¶é—´å¤æ‚åº¦$O((|V| - 1)(|E||V| + |E|)) = O(|V|^2 |E|)$

## 3. The Version of Shimon Even and Alon Itai

å¯¹äºåŸå§‹ç‰ˆæœ¬çš„ä¼˜åŒ–æœ‰å¾ˆå¤šï¼š
- ä½¿ç”¨ä¸¤ç«¯åˆ†å±‚ç½‘ç»œ$\hat{L}(s,t)$æ˜¯ä¸€ç§å¥¢ä¾ˆï¼›å•ç«¯åˆ†å±‚ç½‘ç»œ$L(s)$å°±è¶³å¤Ÿäº†ã€‚
- åˆ†å±‚ç½‘ç»œåœ¨$s$æ–¹å‘ä¸Šï¼ˆå³ä»å·¦å¾€å³ï¼‰åº”è¯¥æ²¡æœ‰æ­»èƒ¡åŒï¼ˆå³æ²¡æœ‰ä¼ å…¥è¾¹ï¼‰ï¼Œè€Œåœ¨$t$æ–¹å‘ä¸Šï¼ˆå³ä»å³å¾€å·¦ï¼‰å­˜åœ¨æ­»èƒ¡åŒä¹Ÿæ²¡æœ‰ä»€ä¹ˆåå¤„ã€‚å› æ­¤ï¼ŒDAå¯ä»¥åˆ‡æ¢åˆ°ç”±$L(s)$åˆå§‹åŒ–çš„åˆ†å±‚ç½‘ç»œ$L$ã€‚
- $L(s)$çš„æ„å»ºå¯ä»¥åœ¨å®Œæˆç¬¬$l$å±‚æ—¶åœæ­¢ã€‚
- DAåªå¯èƒ½å»é™¤$s$æ–¹å‘ä¸Šçš„æ­»è§’ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨$Cleaning$æ—¶ï¼Œä»…æ‰§è¡Œ$RightPass(Q^r)$å°±è¶³å¤Ÿäº†ã€‚
- $L(s)$çš„åŸå§‹å±æ€§ï¼ˆå³ä»$s$åˆ°æ‰€æœ‰å¯åˆ°è¾¾çš„é¡¶ç‚¹çš„æ‰€æœ‰æœ€çŸ­è·¯å¾„çš„å¹¶é›†ï¼‰**ä¸ä¼š**è¢«è¿™ç§ç»´æŠ¤æ‰€ä¿ç•™ã€‚ç„¶è€Œï¼Œè¿™å¯¹äºDAæ¥è¯´å¹¶ä¸æ˜¯å¿…éœ€çš„ï¼Œå› ä¸ºå®ƒä»…ä½¿ç”¨åˆ°$t$çš„æœ€çŸ­è·¯å¾„ã€‚æ­¤æ—¶çš„$L$å®é™…ä¸Šçš„ä¸å˜å¼æ˜¯åŒ…å«æ‰€æœ‰çš„å¢å¹¿è·¯ï¼ˆä¸æ˜¯å®ƒä»¬çš„å¹¶é›†ï¼‰ï¼ŒåŒæ—¶ä¸å­˜åœ¨æ›´çŸ­çš„å¢å¹¿è·¯ã€‚

Evenå’ŒItaiæ‰¿è®¤$L$ä¸­ä¸¤ä¸ªæ–¹å‘éƒ½æœ‰æ­»èƒ¡åŒï¼›å› æ­¤ï¼Œä»–ä»¬å–æ¶ˆäº†$Cleaning$å¹¶æ”¾å¼ƒä½¿ç”¨$PathFinding$ã€‚ä»–ä»¬æå‡ºäº†å¦ä¸€ç§å¯»æ‰¾å¢å¹¿è·¯çš„æ–¹æ³•ï¼šä»¥DFSä¸ºæ¨¡æ¿ï¼Œå»é™¤å…¶é‡åˆ°çš„æ­»èƒ¡åŒã€‚
DFSå¼€å§‹ä»$s$æ„å»ºä¸€æ¡è·¯å¾„ï¼Œä»ä¸€å±‚åˆ°ä¸‹ä¸€å±‚é€å¼§é€’å¢ã€‚è¿™ç§è·¯å¾„æ„å»ºè¦ä¹ˆåœ¨åˆ°è¾¾$t$ï¼ˆæˆåŠŸï¼‰æ—¶åœæ­¢ï¼Œè¦ä¹ˆåœ¨å¦ä¸€ä¸ªæ­»èƒ¡åŒå¤„åœæ­¢ã€‚åœ¨åä¸€ç§æƒ…å†µä¸‹ï¼ŒDFS å›æº¯åˆ°é€šå‘è¯¥æ­»èƒ¡åŒçš„å¼§çš„å°¾éƒ¨ï¼ŒåŒæ—¶å°†è¯¥å¼§è§†ä¸ºæ— ç”¨è€Œä»$L$ä¸­åˆ é™¤ï¼ˆå³ä¸åŒ…å«åœ¨$L$ä¸­çš„ä»$s$åˆ°$t$çš„ä»»ä½•è·¯å¾„ä¸­ï¼‰ã€‚ä¹‹åï¼ŒDFSç»§ç»­å¦‚ä¸Šæ‰€è¿°ï¼Œåœ¨å¯èƒ½çš„æƒ…å†µä¸‹å¢åŠ å½“å‰è·¯å¾„ï¼Œå¦åˆ™å›æº¯å¹¶åˆ é™¤$L$ä¸­çš„æœ€åä¸€æ¡å¼§ã€‚å½“DFSä½äº$s$å¹¶ä¸”æ²¡æœ‰å‡ºè¾¹å¯ä»¥ç¦»å¼€æ—¶ï¼ˆè¡¨æ˜è¯¥é˜¶æ®µå·²å®Œæˆï¼‰æˆ–åˆ°è¾¾$t$æ—¶ï¼Œæ­¤è¿‡ç¨‹ç»“æŸã€‚åœ¨åä¸€ç§æƒ…å†µä¸‹ï¼ŒDFSæ„å»ºäº†ä¸€æ¡å¢å¹¿è·¯å¾„ã€‚ç„¶åï¼Œæ²¿ç€è¯¥è·¯å¾„æ‰§è¡Œæµé‡å˜åŒ–ï¼ŒåŒæ—¶ä»$L$ä¸­ç§»é™¤å…¶å·²é¥±å’Œçš„æ‰€æœ‰å¼§ï¼šæ˜¾ç„¶è‡³å°‘æœ‰ä¸€ä¸ªè¿™æ ·çš„å¼§ã€‚

## 4. Implementation of DA by Cherkassky

```pseudocode
/* Input:*/
    a flow network G = (V, E, c, s, t),
    a feasible flow f, in G (equal to zero, by default).
Initialization:
    compute âˆ€e âˆˆ E : c_f(e) = c(e) âˆ’ f(e);
/* Phase Loop:*/
    dowhile
    begin
        compute âˆ€v âˆˆ V : rank(v)=dist(v,t),
        by BFS from t on edges with c_f > 0,
        in the inverse edge direction;
        if rank(s) = âˆ then
        begin
            f â† c âˆ’ c_f;
            return f;
            /*æ­¤å¤„çš„c - c_fæŒ‡çš„æ˜¯å›´ç€æºç‚¹æˆ–è€…æ±‡ç‚¹çš„é‚£ä¸€åœˆå¼§*/
        end;
        while DFS from s do
        begin
            /âˆ— P denotes the current path
            and x the current vertex of DFS âˆ—/
            any edge (x,y) s.t. c_f(x,y) = 0
            or rank(y) != rank(x) âˆ’ 1 is skipped;
            if x = t then
            begin
                Ïµ â† min{c_f(e) : e âˆˆ P};
                for edges (v, u) of P, from t downto s do
                begin
                    c_f(v, u) â† c_f(v, u) âˆ’ Ïµ;
                    c_f(u, v) â† c_f(u, v) + Ïµ;
                    if c_f(u, v) = 0 then x â† u;
                end;
                /âˆ— continue DFS from x âˆ—/
            end;
        end;
    end;
```

## Other: é€‚ç”¨äºå®é™…ç¼–å†™ç®—æ³•çš„ä¼ªä»£ç 

```pseudocode
Input: G = <V , A , c , s , t>
Output: The max flow in G from s to t
Dinitz:
    res := 0
    while bfs() do:
        while flow := dfs(s , curflow) do:
            res â† res + flow
    return res

bfs():
    q.clear()
    q.push(s)
    depth.clear()
    depth[s] â† 1

    do:
        u := q.front()
        q.pop()
        foreach <u , v> in A do:
            if r(<u , v>) > 0 and depth[v] is 0 do:
                depth[v] â† depth[u] + 1
                q.push(v)
    while q is not empty

    if depth[t] is 0
        return false
    return true

dfs(u , curflow):
    if u is t
        return curflow
    foreach <u , v> in A do:
        if depth[v] is depth[u] + 1 and r[v] is not 0 do:
            nextflow := dfs(v , min(curflow , r(<u , v>)))
            if nextflow is not 0 do:
                reduce reversed edge weight
                add upright edge weight
                return nextflow // transmit to upper level
    return 0
```

ä¸ºä»€ä¹ˆæˆ‘åœ¨æˆ‘çš„ç”Ÿæ—¥å‰è¿˜è¦çœ‹è®ºæ–‡ã€å†™Labå’Œå¤ä¹ æœŸä¸­è€ƒï¼ˆç¢ç¢å¿µï¼‰